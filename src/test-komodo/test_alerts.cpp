// Copyright (c) 2013 The Bitcoin Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

//
// Unit tests for alert system
//

#include "alert.h"
#include "chain.h"
#include "chainparams.h"
#include "clientversion.h"

#include "main.h"
#include "rpc/protocol.h"
#include "rpc/server.h"
#include "serialize.h"
#include "streams.h"
#include "util.h"
#include "utilstrencodings.h"

#include "test/test_bitcoin.h"

#include <fstream>

#include <boost/filesystem/operations.hpp>
#include <boost/foreach.hpp>
#include <gtest/gtest.h>

#include "key.h"
#include <iostream>
#include <cstdio> // for ::remove
#include <thread>

namespace TestAlerts
{

// macro to assist with log messages
#define GTEST_COUT std::cerr << "[          ] [ INFO ] "

// Code to output a C-style array of values
template<typename T>
std::string HexStrArray(const T itbegin, const T itend, int lineLength)
{
    std::string rv;
    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',
                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
    rv.reserve((itend-itbegin)*3);
    int i = 0;
    for(T it = itbegin; it < itend; ++it)
    {
        unsigned char val = (unsigned char)(*it);
        if(it != itbegin)
        {
            if (i % lineLength == 0)
                rv.push_back('\n');
            else
                rv.push_back(' ');
        }
        rv.push_back('0');
        rv.push_back('x');
        rv.push_back(hexmap[val>>4]);
        rv.push_back(hexmap[val&15]);
        rv.push_back(',');
        i++;
    }

    return rv;
}

template<typename T>
inline std::string HexStrArray(const T& vch, int lineLength)
{
    return HexStrArray(vch.begin(), vch.end(), lineLength);
}

// Stuff used by several tests, and set up by TestAlerts::SetupTestCase()
boost::filesystem::path alertnotify_file;
CKey key;
CPubKey pubKey;
std::vector<CAlert> alerts;
boost::filesystem::path temp_directory = boost::filesystem::temp_directory_path();
boost::filesystem::path binary_file;

class TestAlerts : public ::testing::Test
{
public:
    TestAlerts()
    {
    }
    ~TestAlerts()
    {
    }
    static void SetUpTestCase()
    {
        // generate a key that will sign alerts
        key.MakeNewKey(false);
        pubKey = key.GetPubKey();
        // a place to store the binary file
        binary_file = temp_directory / "testAlerts.raw";
        // generate the alerts
        GenerateAlertTests();
        // Now read it into the alerts collection
        ReadAlerts(binary_file);
        alertnotify_file = GetTempPath() /
            boost::filesystem::unique_path("alertnotify-%%%%.txt");
        mapArgs["-alertnotify"] = std::string("echo %s >> ") + alertnotify_file.string();
    }
    static void TearDownTestCase()
    {
        if (!boost::filesystem::remove( alertnotify_file) )
            GTEST_COUT << "Boost says it was unable to remove file " << alertnotify_file.string() 
                    << std::endl;
        if (!boost::filesystem::remove(binary_file))
            GTEST_COUT << "Unable to remove file " << binary_file.string() << std::endl;
    }

    virtual void SetUp() {}

    virtual void TearDown() {}

    /******
     * @brief reads the alerts that were generated by GenerateAlertTests
     */
    static std::vector<std::string> ReadLines(boost::filesystem::path filepath)
    {
        std::vector<std::string> result;

        std::ifstream f(filepath.string().c_str());
        std::string line;
        while (std::getline(f,line))
            result.push_back(line);
        f.close();
        return result;
    }

    static bool ReadAlerts(boost::filesystem::path infile)
    {
        // read the file into a vector
        std::ifstream filestream(binary_file.string().c_str(), std::ios::in | std::ios::binary);
        std::vector<unsigned char> vch( (std::istreambuf_iterator<char>(filestream)), std::istreambuf_iterator<char>());

        CDataStream stream(vch, SER_DISK, CLIENT_VERSION);
        try {
            while (!stream.eof())
            {
                CAlert alert;
                stream >> alert;
                alerts.push_back(alert);
            }
        }
        catch (const std::exception&) { return false; }
        return true;
    }

    static void GenerateAlertTests()
    {
        CDataStream sBuffer(SER_DISK, CLIENT_VERSION);

        CAlert alert;
        alert.nRelayUntil   = 60;
        alert.nExpiration   = 24 * 60 * 60;
        alert.nID           = 1;
        alert.nCancel       = 0;  // cancels previous messages up to this ID number
        alert.nMinVer       = 0;  // These versions are protocol versions
        alert.nMaxVer       = 999001;
        alert.nPriority     = 1;
        alert.strComment    = "Alert comment";
        alert.strStatusBar  = "Alert 1";

        // Replace SignAndSave with SignAndSerialize
        SignAndSerialize(alert, sBuffer);

        // More tests go here ...
        alert.setSubVer.insert(std::string("/MagicBean:0.1.0/"));
        alert.strStatusBar  = "Alert 1 for MagicBean 0.1.0";
        SignAndSerialize(alert, sBuffer);

        alert.setSubVer.insert(std::string("/MagicBean:0.2.0/"));
        alert.strStatusBar  = "Alert 1 for MagicBean 0.1.0, 0.2.0";
        SignAndSerialize(alert, sBuffer);

        alert.setSubVer.clear();
        ++alert.nID;
        alert.nCancel = 1;
        alert.nPriority = 100;
        alert.strStatusBar  = "Alert 2, cancels 1";
        SignAndSerialize(alert, sBuffer);

        alert.nExpiration += 60;
        ++alert.nID;
        SignAndSerialize(alert, sBuffer);

        ++alert.nID;
        alert.nPriority = 5000;
        alert.strStatusBar  = "Alert 3, disables RPC";
        alert.strRPCError = "RPC disabled";
        SignAndSerialize(alert, sBuffer);

        ++alert.nID;
        alert.nPriority = 5000;
        alert.strStatusBar  = "Alert 4, re-enables RPC";
        alert.strRPCError = "";
        SignAndSerialize(alert, sBuffer);

        ++alert.nID;
        alert.nMinVer = 11;
        alert.nMaxVer = 22;
        alert.nPriority = 100;
        SignAndSerialize(alert, sBuffer);

        ++alert.nID;
        alert.strStatusBar  = "Alert 2 for MagicBean 0.1.0";
        alert.setSubVer.insert(std::string("/MagicBean:0.1.0/"));
        SignAndSerialize(alert, sBuffer);

        ++alert.nID;
        alert.nMinVer = 0;
        alert.nMaxVer = 999999;
        alert.strStatusBar  = "Evil Alert'; /bin/ls; echo '";
        alert.setSubVer.clear();
        bool b = SignAndSerialize(alert, sBuffer);

        if (b) {
            // write alerts to a file
            std::vector<unsigned char> vch = std::vector<unsigned char>(sBuffer.begin(), sBuffer.end());
            std::ofstream outfile(binary_file.string().c_str(), std::ios::out | std::ios::binary);
            outfile.write((const char*)&vch[0], vch.size());
            outfile.close();
        }
    }

    // Sign CAlert with alert private key
    static bool SignAlert(CAlert &alert)
    {
        // serialize alert data
        CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);
        sMsg << *(CUnsignedAlert*)&alert;
        alert.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());

        // sign alert
        if (!key.Sign(Hash(alert.vchMsg.begin(), alert.vchMsg.end()), alert.vchSig))
        {
            printf("SignAlert() : key.Sign failed\n");
            return false;
        }
        return true;
    }

    // Sign a CAlert and serialize it
    static bool SignAndSerialize(CAlert &alert, CDataStream &buffer)
    {
        // Sign
        if(!SignAlert(alert))
        {
            printf("SignAndSerialize() : could not sign alert\n");
            return false;
        }
        // ...and save!
        buffer << alert;
        return true;
    }
};

TEST_F(TestAlerts, AlertApplies)
{
    SetMockTime(11);
    std::vector<unsigned char> alertKey{pubKey.begin(), pubKey.end()};

    for(const CAlert& alert : alerts)
    {
        EXPECT_TRUE(alert.CheckSignature(alertKey));
    }

    EXPECT_GE(alerts.size(), 3);

    // Matches:
    EXPECT_TRUE(alerts[0].AppliesTo(1, ""));
    EXPECT_TRUE(alerts[0].AppliesTo(999001, ""));
    EXPECT_TRUE(alerts[0].AppliesTo(1, "/MagicBean:11.11.11/"));

    EXPECT_TRUE(alerts[1].AppliesTo(1, "/MagicBean:0.1.0/"));
    EXPECT_TRUE(alerts[1].AppliesTo(999001, "/MagicBean:0.1.0/"));

    EXPECT_TRUE(alerts[2].AppliesTo(1, "/MagicBean:0.1.0/"));
    EXPECT_TRUE(alerts[2].AppliesTo(1, "/MagicBean:0.2.0/"));

    // Don't match:
    EXPECT_TRUE(!alerts[0].AppliesTo(-1, ""));
    EXPECT_TRUE(!alerts[0].AppliesTo(999002, ""));

    EXPECT_TRUE(!alerts[1].AppliesTo(1, ""));
    EXPECT_TRUE(!alerts[1].AppliesTo(1, "MagicBean:0.1.0"));
    EXPECT_TRUE(!alerts[1].AppliesTo(1, "/MagicBean:0.1.0"));
    EXPECT_TRUE(!alerts[1].AppliesTo(1, "MagicBean:0.1.0/"));
    EXPECT_TRUE(!alerts[1].AppliesTo(-1, "/MagicBean:0.1.0/"));
    EXPECT_TRUE(!alerts[1].AppliesTo(999002, "/MagicBean:0.1.0/"));
    EXPECT_TRUE(!alerts[1].AppliesTo(1, "/MagicBean:0.2.0/"));

    EXPECT_TRUE(!alerts[2].AppliesTo(1, "/MagicBean:0.3.0/"));

    SetMockTime(0);
}


TEST_F(TestAlerts, AlertNotify)
{
    SetMockTime(11);
    const std::vector<unsigned char>& alertKey{pubKey.begin(), pubKey.end()};

    for(CAlert alert : alerts)
        alert.ProcessAlert(alertKey, false);

    std::vector<std::string> r = ReadLines( alertnotify_file);
    EXPECT_EQ(r.size(), 6u);

// Windows built-in echo semantics are different than posixy shells. Quotes and
// whitespace are printed literally.

#ifndef WIN32
    EXPECT_EQ(r[0], "Alert 1");
    EXPECT_EQ(r[1], "Alert 2, cancels 1");
    EXPECT_EQ(r[2], "Alert 2, cancels 1");
    EXPECT_EQ(r[3], "Alert 3, disables RPC");
    EXPECT_EQ(r[4], "Alert 4, reenables RPC"); // dashes should be removed
    EXPECT_EQ(r[5], "Evil Alert; /bin/ls; echo "); // single-quotes should be removed
#else
    EXPECT_EQ(r[0], "'Alert 1' ");
    EXPECT_EQ(r[1], "'Alert 2, cancels 1' ");
    EXPECT_EQ(r[2], "'Alert 2, cancels 1' ");
    EXPECT_EQ(r[3], "'Alert 3, disables RPC' ");
    EXPECT_EQ(r[4], "'Alert 4, reenables RPC' "); // dashes should be removed
    EXPECT_EQ(r[5], "'Evil Alert; /bin/ls; echo ' ");
#endif

    SetMockTime(0);
    mapAlerts.clear();
}

TEST_F(TestAlerts, AlertDisablesRPC)
{
    SetMockTime(11);
    const std::vector<unsigned char>& alertKey{pubKey.begin(), pubKey.end()};

    // Command should work before alerts
    EXPECT_EQ(GetWarnings("rpc"), "");

    // First alert should disable RPC
    alerts[5].ProcessAlert(alertKey, false);
    EXPECT_EQ(alerts[5].strRPCError, "RPC disabled");
    EXPECT_EQ(GetWarnings("rpc"), "RPC disabled");

    // Second alert should re-enable RPC
    alerts[6].ProcessAlert(alertKey, false);
    EXPECT_EQ(alerts[6].strRPCError, "");
    EXPECT_EQ(GetWarnings("rpc"), "");

    SetMockTime(0);
    mapAlerts.clear();
}

static bool falseFunc() { return false; }

TEST_F(TestAlerts, PartitionAlert)
{
    // Test PartitionCheck
    CCriticalSection csDummy;
    CChainParams& params = Params(CBaseChainParams::MAIN);
    int64_t nPowTargetSpacing = params.GetConsensus().nPowTargetSpacing; // for komodo mainnet, currently 60
    int64_t normalBlocksPerDay = 86400 / nPowTargetSpacing;
    CBlockIndex indexDummy[86400 / 60]; // hard coded to avoid compiler warnings about variable length buffer

    // Generate fake blockchain timestamps relative to
    // an arbitrary time:
    int64_t now = 1427379054;
    SetMockTime(now);
    for (int i = 0; i < normalBlocksPerDay; i++)
    {
        indexDummy[i].phashBlock = nullptr;
        if (i == 0) 
            indexDummy[i].pprev = nullptr;
        else 
            indexDummy[i].pprev = &indexDummy[i-1];
        indexDummy[i].nHeight = i;
        indexDummy[i].nTime = now - (normalBlocksPerDay-i)*nPowTargetSpacing;
        // Other members don't matter, the partition check code doesn't
        // use them
    }

    // Test 1: chain with blocks every nPowTargetSpacing seconds,
    // as normal, no worries:
    PartitionCheck(falseFunc, csDummy, &indexDummy[normalBlocksPerDay - 1], nPowTargetSpacing);
    EXPECT_TRUE(strMiscWarning.empty());

    // Test 2: go 3.5 hours without a block, expect a warning:
    now += 3*60*60+30*60;
    SetMockTime(now);
    PartitionCheck(falseFunc, csDummy, &indexDummy[normalBlocksPerDay - 1], nPowTargetSpacing);
    EXPECT_TRUE(!strMiscWarning.empty());
    GTEST_COUT << "Got alert text: " << strMiscWarning << std::endl;
    strMiscWarning = "";

    // Test 3: test the "partition alerts only go off once per day"
    // code:
    now += 60*10;
    SetMockTime(now);
    PartitionCheck(falseFunc, csDummy, &indexDummy[normalBlocksPerDay - 1], nPowTargetSpacing);
    EXPECT_TRUE(strMiscWarning.empty());

    // Test 4: get 2.5 times as many blocks as expected:
    now += 60*60*24; // Pretend it is a day later
    SetMockTime(now);
    int64_t quickSpacing = nPowTargetSpacing*2/5;
    for (int i = 0; i < normalBlocksPerDay; i++) // Tweak chain timestamps:
        indexDummy[i].nTime = now - (normalBlocksPerDay-i)*quickSpacing;
    PartitionCheck(falseFunc, csDummy, &indexDummy[normalBlocksPerDay - 1], nPowTargetSpacing);
    EXPECT_TRUE(!strMiscWarning.empty());
    GTEST_COUT << "Got alert text: " << strMiscWarning << std::endl;
    strMiscWarning = "";

    SetMockTime(0);
    // PartitionCheck adds records to the alertnotify file asynchronously. 
    // To remove the file, we need to wait briefly for it to be closed.
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
}

} // namespace TestAlerts
